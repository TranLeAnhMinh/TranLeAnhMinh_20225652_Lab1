1. Lớp nào nên triển khai interface Comparable?
Lớp cần triển khai interface Comparable là những lớp mà bạn muốn sắp xếp các đối tượng của chúng dựa trên các thuộc tính của lớp đó. Ví dụ, nếu bạn có một lớp tên là Item đại diện cho các sản phẩm trong giỏ hàng, lớp này sẽ triển khai Comparable<Item> để có thể so sánh và sắp xếp các đối tượng Item.

public class Item implements Comparable<Item> {
    private String title;
    private double cost;

    // Constructor, getters và setters được bỏ qua để tiết kiệm không gian

    @Override
    public int compareTo(Item other) {
        // Logic so sánh sẽ được thực hiện ở đây
    }
}
Phương thức compareTo() phải trả về một số nguyên để chỉ rõ thứ tự của đối tượng hiện tại so với đối tượng khác
2. Trong những lớp đó, bạn nên triển khai phương thức compareTo() như thế nào để phản ánh thứ tự mà chúng ta muốn?
Một số nguyên âm nếu đối tượng này nhỏ hơn đối tượng đã chỉ định.
Zero nếu hai đối tượng bằng nhau.
Một số nguyên dương nếu đối tượng này lớn hơn đối tượng đã chỉ định.
Ví dụ, nếu bạn muốn sắp xếp các mục trước tiên theo tiêu đề và sau đó theo chi phí, cách triển khai có thể như sau:

@Override
public int compareTo(Item other) {
    int titleComparison = this.title.compareTo(other.title);
    if (titleComparison != 0) {
        return titleComparison; // Sắp xếp theo tiêu đề
    }
    return Double.compare(this.cost, other.cost); // Sắp xếp theo chi phí
}
3. Chúng ta có thể có hai quy tắc sắp xếp của mục (theo tiêu đề rồi đến chi phí và theo chi phí rồi đến tiêu đề) nếu chúng ta sử dụng cách tiếp cận interface Comparable không?
Không, chúng ta không thể có hai quy tắc sắp xếp khác nhau trong một lớp khi chỉ sử dụng interface Comparable. Lý do là phương thức compareTo() chỉ có thể chứa một quy tắc sắp xếp duy nhất, tức là bạn chỉ có thể so sánh các đối tượng dựa trên một tiêu chí (hoặc theo tiêu đề rồi đến chi phí, hoặc theo chi phí rồi đến tiêu đề) trong mỗi lần triển khai.
4. Giả sử các DVD có quy tắc sắp xếp khác với các loại phương tiện khác, đó là theo tiêu đề, sau đó là độ dài giảm dần, rồi đến chi phí. Bạn sẽ sửa đổi mã của mình như thế nào để cho phép điều này?
Nếu các DVD có quy tắc sắp xếp riêng biệt (theo tiêu đề, sau đó là độ dài giảm dần và cuối cùng là chi phí), bạn có thể thực hiện điều này bằng cách tạo một lớp riêng cho DVD và triển khai interface Comparable. Dưới đây là cách thực hiện:

public class DVD implements Comparable<DVD> {
    private String title;
    private double length; // Giả sử độ dài tính bằng phút
    private double cost;

    @Override
    public int compareTo(DVD other) {
        // So sánh theo tiêu đề
        int titleComparison = this.title.compareTo(other.title);
        if (titleComparison != 0) {
            return titleComparison; // Trả về kết quả so sánh tiêu đề nếu không bằng nhau
        }
        
        // So sánh theo độ dài (giảm dần)
        int lengthComparison = Double.compare(other.length, this.length); // Đảo ngược so với bình thường
        if (lengthComparison != 0) {
            return lengthComparison; // Trả về kết quả so sánh độ dài nếu không bằng nhau
        }

        // So sánh theo chi phí
        return Double.compare(this.cost, other.cost); // Trả về kết quả so sánh chi phí
    }
}
Giải thích: So sánh theo tiêu đề: Dùng phương thức compareTo() của lớp String để sắp xếp theo thứ tự alphabet.
            So sánh theo độ dài: Để đảm bảo độ dài được sắp xếp giảm dần, ta đảo ngược so sánh giữa this.length và other.length bằng cách gọi                    Double.compare(other.length, this.length).
            So sánh theo chi phí: Cuối cùng, dùng Double.compare() để sắp xếp các DVD theo chi phí theo thứ tự tăng dần.
